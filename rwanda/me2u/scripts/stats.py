import sys, datetime, math# Store all the tower ids and their lat/lontfhandle = open("../data/towers.csv")tower_locations = {}for line in tfhandle:	line = line.split(',')	tower_id, long, lat = line[0], line[2], line[3]	tower_locations[tower_id] = (long, lat)class Location:	def __init__(self, lat, lon, siteid='', sitename=''):		self.lat = float(lat)		self.lon = float(lon)		self.siteid = siteid		self.sitename = sitename		self.incoming_locs = {}		self.outgoing_locs = {}		self.incoming_amt, self.outgoing_amt = {}, {}		self.incoming_locs_joined_without_receiving = {}		self.outgoing_locs_joined_without_receiving = {}		self.incoming_locs_joined_with_receiving = {}		self.outgoing_locs_joined_with_receiving = {}		self.incoming_locs_didnt_join = {}		self.outgoing_locs_didnt_join = {}		def distance(self, loc):		R = 6378.16 # km		dlon = loc.lon - self.lon		dlat = loc.lat - self.lat		a = (math.sin(dlat / 2) * math.sin(dlat / 2)) + \		math.cos(self.lat) * math.cos(loc.lat) * (math.sin(dlon / 2) * math.sin(dlon / 2))		angle = 2 * math.atan2(a**0.5, (1 - a) ** 0.5)		return angle * R	class Person:	def __init__(self, pid, self_loc, partner_loc):		self.pid = pid		self.appear_date = None		self.joined_date = None				if self_loc in tower_locations and partner_loc in tower_locations:			self.self_locs = [self.get_new_loc(self_loc)]			self.partner_locs = [self.get_new_loc(partner_loc)]		else:			self.self_locs = []			self.partner_locs = []				self.incoming_me2u, self.outgoing_me2u = 0, 0		self.incoming_amt, self.outgoing_amt = 0, 0		self.incoming_call, self.outgoing_call = 0, 0		self.incoming_call_mins, self.outgoing_call_mins = 0, 0		self.incoming_amt_before_joining = 0.0		def get_new_loc(self, locid):		return Location(tower_locations[locid][0], tower_locations[locid][1], locid)		def set_appear_date(self, d):		self.appear_date = datetime.date(int('20' + d[0:2]), int(d[2:4]), int(d[4:6]))		def set_join_date(self, d):		self.joined_date = datetime.date(int('20' + d[0:2]), int(d[2:4]), int(d[4:6]))		def add_self_loc(self, loc):		self.self_locs.append(self.get_new_loc(loc))			def add_partner_loc(self, loc):		self.partner_locs.append(self.get_new_loc(loc))	def get_self_loc(self):		avg_lon, avg_lat = [0.0, 0], [0.0, 0]		for loc in self.self_locs:			avg_lon[0] += loc.lon			avg_lat[0] += loc.lat			avg_lon[1] += 1			avg_lat[1] += 1		return Location(avg_lat[0]/avg_lat[1], avg_lon[0]/avg_lon[1])			def add_incoming_me2u(self):		self.incoming_me2u += 1  # incoming me2u transfers person receives	def add_outgoing_me2u(self):		self.outgoing_me2u += 1  # outgoing me2u transfers person makes	def add_incoming_call(self):		self.incoming_call += 1  # incoming calls person receives	def add_outgoing_call(self):		self.outgoing_call += 1  # outgoing calls person makes		def get_avg_distance(self):		dist_sum, i = 0.0, 0		while i < len(self.self_locs):			loc1, loc2 = self.self_locs[i], self.partner_locs[i]			dist_sum += loc1.distance(loc2)			i += 1		if len(self.self_locs) == 0: return None		return dist_sum/len(self.self_locs)			class Stats:	def __init__(self, how_much):		self.how_much = int(how_much)		# obtain all stats from various files		self.database = {} # db of pid to Persons		self.locations = {}		def generate_tables(self):		f = open("../data/me2u.locs.valid.txt")		i = 0		for line in f:			if i < self.how_much:				if i % 50000 == 0: print "processed line", i				# split the line and match the columns to variables				line = line.split(',')				person1, person2, date, time, amount = line[0:5]				loc1, loc2 = line[5], line[8]								###############				# create an entry in the location database				###############				if loc1 in tower_locations and loc2 in tower_locations:					if loc1 not in self.locations:						self.locations[loc1] = Location(tower_locations[loc1][0], tower_locations[loc1][1])					if loc2 not in self.locations:						self.locations[loc2] = Location(tower_locations[loc2][0], tower_locations[loc2][1])											if loc2 in self.locations[loc1].outgoing_locs: self.locations[loc1].outgoing_locs[loc2] += 1					else: self.locations[loc1].outgoing_locs[loc2] = 0					if loc1 in self.locations[loc2].incoming_locs: self.locations[loc2].incoming_locs[loc1] += 1					else: self.locations[loc2].incoming_locs[loc1] = 0										if loc2 in self.locations[loc1].outgoing_amt: self.locations[loc1].outgoing_amt[loc2] += int(amount)					else: self.locations[loc1].outgoing_amt[loc2] = int(amount)					if loc1 in self.locations[loc2].incoming_amt: self.locations[loc2].incoming_amt[loc1] += int(amount)					else: self.locations[loc2].incoming_amt[loc1] = int(amount)								# put the sender into the database				if person1 not in self.database:					self.database[person1] = Person(person1, loc1, loc2)					self.database[person1].set_appear_date(date) # the day they join is the same day they appear				else:					if loc1 in tower_locations and loc2 in tower_locations:						self.database[person1].add_self_loc(loc1)						self.database[person1].add_partner_loc(loc2)				if self.database[person1].joined_date == None:					self.database[person1].set_join_date(date)				self.database[person1].add_outgoing_me2u()				self.database[person1].outgoing_amt += int(amount)								# put receiver into database				if person2 not in self.database:					self.database[person2] = Person(person2, loc2, loc1)					self.database[person2].set_appear_date(date)				else:					if loc1 in tower_locations and loc2 in tower_locations:						self.database[person2].add_self_loc(loc2)						self.database[person2].add_partner_loc(loc1)				if self.database[person2].joined_date == None:					self.database[person2].incoming_amt_before_joining += int(amount)				self.database[person2].add_incoming_me2u()				self.database[person2].incoming_amt += int(amount)							else: break			i += 1		def make_loc_maps(self):		locmap = self.locations.items()		locamtfile = open("../data/locations_data", 'w')		locamtfile.write("location_id\t#_incoming_me2u\t#_outgoing_me2u\tincoming_amount\toutgoing_amount\n")				for lid, loc in locmap:			locamtfile.write(str(lid) + "\t" + str(sum(loc.incoming_locs.values())) + "\t" + str(sum(loc.outgoing_locs.values()))\							+ "\t" + str(sum(loc.incoming_amt.values())) + "\t" + str(sum(loc.outgoing_amt.values())) + "\n")		locamtfile.close()				for lid, loc in locmap:			locfile = open("../data/locations/" + str(lid), 'w')			locfile.write("location_id\t#_incoming_me2u\t#_outgoing_me2u\tincoming_amount\toutgoing_amount\n")			print loc.incoming_locs			for locid in tower_locations.keys():				if locid in loc.incoming_locs:					print locid, loc.incoming_locs[locid], "|", 				locfile.write(str(locid.strip()) + "\t" + (str(loc.incoming_locs[locid]) if locid in loc.incoming_locs else '0')\				+ "\t" + (str(loc.outgoing_locs[locid]) if locid in loc.outgoing_locs else '0')\				+ "\t" + (str(loc.incoming_amt[locid]) if locid in loc.incoming_amt else '0')\				+ "\t" + (str(loc.outgoing_amt[locid]) if locid in loc.outgoing_amt else '0') + "\n")			print ""			locfile.close()		def make_hist(self):		dbmap = self.database.items()		one, two, three = open("../data/didnt_receive_before_joining", 'w'), open("../data/received_before_joining", 'w'), open("../data/didnt_join", 'w')		one.write("distance\tincomingamt\toutgoingamt\tincomingno\toutgoingno\n")		two.write("distance\tincomingamt\toutgoingamt\tincomingno\toutgoingno\n")		three.write("incomingamt\toutgoingamt\tincomingno\toutgoingno\n")				for pid, person in dbmap:			if person.joined_date != None:				# person joined without receiving any me2u prior to joining				if person.appear_date == person.joined_date:					for partner in person.partner_locs:						one.write(str(person.get_self_loc().distance(partner)) + "\t" + str(person.incoming_amt)\						+ "\t" + str(person.outgoing_amt) + "\t" + str(person.incoming_me2u) + "\t" + str(person.outgoing_me2u) + "\n")				# person joined after receiving me2u				elif person.appear_date < person.joined_date:					for partner in person.partner_locs:						two.write(str(person.get_self_loc().distance(partner)) + "\t" + str(person.incoming_amt)\						+ "\t" + str(person.outgoing_amt) + "\t" + str(person.incoming_me2u) + "\t" + str(person.outgoing_me2u) + "\n")			else:				# people who never joined				three.write(str(person.incoming_amt)\						+ "\t" + str(person.outgoing_amt) + "\t" + str(person.incoming_me2u) + "\t" + str(person.outgoing_me2u) + "\n")		def print_db(self):		dbmap = self.database.items()		print "Unique people:", len(dbmap)		sum_dist_not_joined, sum_dist_joined, not_joined_count, joined_count = 0.0,0.0,0.0,0.0		not_joined_dist_ct, joined_dist_ct = 0.0, 0.0				# amounts a person receives or gives, sorted by joined or not		incoming_amt_joined, incoming_amt_not = [0.0,0.0],[0.0,0.0]		outgoing_amt_joined, outgoing_amt_not = [0.0,0.0],[0.0,0.0]				# the incoming amt for people who joined, but not for 		# those who joined the network without receiving anything		incoming_amt_joined_wo_zeroes = [0.0,0.0]				incoming_amt_before_join = [0.0,0.0]				for pid, person in dbmap:			avg_dist = person.get_avg_distance()						# Calculate amounts averages by joined or not			if person.joined_date != None:				incoming_amt_joined[0] += person.incoming_amt				incoming_amt_joined[1] += 1				outgoing_amt_joined[0] += person.outgoing_amt				outgoing_amt_joined[1] += 1				incoming_amt_before_join[0] += person.incoming_amt_before_joining				incoming_amt_before_join[1] += 1				if person.incoming_amt != 0:					incoming_amt_joined_wo_zeroes[0] += person.incoming_amt					incoming_amt_joined_wo_zeroes[1] += 1			else:				incoming_amt_not[0] += person.incoming_amt				incoming_amt_not[1] += 1				outgoing_amt_not[0] += person.outgoing_amt				outgoing_amt_not[1] += 1						# Calculates distance averages by joined or not			if person.joined_date == None:				if avg_dist != None:					sum_dist_not_joined += avg_dist					not_joined_dist_ct += 1				not_joined_count += 1			else:				if avg_dist != None:					sum_dist_joined += avg_dist					joined_dist_ct += 1				joined_count += 1				print "Of that,", joined_count, "joined the me2u network or", joined_count/len(dbmap)*100.0, "%"		print "Of that,", not_joined_count, "did not join the me2u network", not_joined_count/len(dbmap)*100.0, "%"		print joined_count - incoming_amt_joined_wo_zeroes[1], "joined me2u without previous transfers"		print incoming_amt_joined_wo_zeroes[1], "joined me2u with previous transfers"		print ""				print "Average incoming amt before joining:", incoming_amt_before_join[0]/incoming_amt_before_join[1]		print "Average dist joined:", sum_dist_joined/joined_dist_ct		print "Average dist not joined:", sum_dist_not_joined/not_joined_dist_ct		print "Average incoming amt for users who joined:", incoming_amt_joined[0]/incoming_amt_joined[1]		print "Average outgoing amt for users who joined:", outgoing_amt_joined[0]/outgoing_amt_joined[1]		print "Average incoming amt for users who didn't join:", incoming_amt_not[0]/incoming_amt_not[1]		print "Average outgoing amt for users who didn't join:", outgoing_amt_not[0]/outgoing_amt_not[1]		print "Average incoming amt for users who joined, no zeroes:", incoming_amt_joined_wo_zeroes[0]/incoming_amt_joined_wo_zeroes[1]		s = Stats(sys.argv[1])s.generate_tables()s.print_db()#s.make_hist()#s.make_loc_maps()